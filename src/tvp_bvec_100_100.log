
Attaching package: â€˜dplyrâ€™

The following objects are masked from â€˜package:statsâ€™:

    filter, lag

The following objects are masked from â€˜package:baseâ€™:

    intersect, setdiff, setequal, union

[?25h[?25h
Attaching package: â€˜data.tableâ€™

The following objects are masked from â€˜package:dplyrâ€™:

    between, first, last

[?25h[?25h
Attaching package: â€˜rlangâ€™

The following object is masked from â€˜package:data.tableâ€™:

    :=

[?25h
Attaching package: â€˜reshape2â€™

The following objects are masked from â€˜package:data.tableâ€™:

    dcast, melt

The following object is masked from â€˜package:tidyrâ€™:

    smiths

[?25h[?25hLoading required package: coda
Warning message:
package â€˜codaâ€™ was built under R version 4.3.2 
[?25hhere() starts at /home/danielco/Downloads/sgd-trading
[?25h[?25hWarning message:
package â€˜optparseâ€™ was built under R version 4.3.3 
[?25h
Attaching package: â€˜lubridateâ€™

The following objects are masked from â€˜package:data.tableâ€™:

    hour, isoweek, mday, minute, month, quarter, second, wday, week,
    yday, year

The following objects are masked from â€˜package:baseâ€™:

    date, intersect, setdiff, union


Attaching package: â€˜zooâ€™

The following objects are masked from â€˜package:baseâ€™:

    as.Date, as.Date.numeric

[?25hError: Unable to load package rollRegres -  there is no package called â€˜rollRegresâ€™
[?25h
Attaching package: â€˜ggplot2â€™

The following object is masked from â€˜package:dlmâ€™:

    %+%

[?25h[?25h[?25h[?25h[?25h[?25h[?25h[?25h[?25h[?25h[?25h[?25h[?25hpad applied on the interval: day
[?25h[?25h[?25h[?25h[?25h[?25h[?25h[?25hEstimating models...

 *** caught segfault ***
address 0x7f594e2695c8, cause 'memory not mapped'

Traceback:
 1: .bvectvpalg(object)
 2: bvecpost(object)
 3: doTryCatch(return(expr), name, parentenv, handler)
 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 5: tryCatchList(expr, classes, parentenv, handlers)
 6: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
 7: try(bvecpost(object))
 8: FUN(X[[i]], ...)
 9: eval(expr, env)
10: doTryCatch(return(expr), name, parentenv, handler)
11: tryCatchOne(expr, names, parentenv, handlers[[1L]])
12: tryCatchList(expr, classes, parentenv, handlers)
13: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
14: try(eval(expr, env), silent = TRUE)
15: serialize(what, NULL, xdr = FALSE)
16: sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
17: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
18: FUN(X[[i]], ...)
19: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
20: parallel::mclapply(object, .posterior_bvecmodel, use = FUN, mc.cores = mc.cores,     mc.preschedule = FALSE)
21: draw_posterior.bvecmodel(temp, mc.cores = num_cores, verbose = TRUE)
22: draw_posterior(temp, mc.cores = num_cores, verbose = TRUE)
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x7f7921c97320, cause 'memory not mapped'

Traceback:
 1: .bvectvpalg(object)
 2: bvecpost(object)
 3: doTryCatch(return(expr), name, parentenv, handler)
 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 5: tryCatchList(expr, classes, parentenv, handlers)
 6: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
 7: try(bvecpost(object))
 8: FUN(X[[i]], ...)
 9: eval(expr, env)
10: doTryCatch(return(expr), name, parentenv, handler)
11: tryCatchOne(expr, names, parentenv, handlers[[1L]])
12: tryCatchList(expr, classes, parentenv, handlers)
13: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
14: try(eval(expr, env), silent = TRUE)
15: serialize(what, NULL, xdr = FALSE)
16: sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
17: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
18: FUN(X[[i]], ...)
19: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
20: parallel::mclapply(object, .posterior_bvecmodel, use = FUN, mc.cores = mc.cores,     mc.preschedule = FALSE)
21: draw_posterior.bvecmodel(temp, mc.cores = num_cores, verbose = TRUE)
22: draw_posterior(temp, mc.cores = num_cores, verbose = TRUE)
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x7f54346e88c0, cause 'memory not mapped'

Traceback:
 1: .bvectvpalg(object)
 2: bvecpost(object)
 3: doTryCatch(return(expr), name, parentenv, handler)
 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 5: tryCatchList(expr, classes, parentenv, handlers)
 6: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
 7: try(bvecpost(object))
 8: FUN(X[[i]], ...)
 9: eval(expr, env)
10: doTryCatch(return(expr), name, parentenv, handler)
11: tryCatchOne(expr, names, parentenv, handlers[[1L]])
12: tryCatchList(expr, classes, parentenv, handlers)
13: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
14: try(eval(expr, env), silent = TRUE)
15: serialize(what, NULL, xdr = FALSE)
16: sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
17: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
18: FUN(X[[i]], ...)
19: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
20: parallel::mclapply(object, .posterior_bvecmodel, use = FUN, mc.cores = mc.cores,     mc.preschedule = FALSE)
21: draw_posterior.bvecmodel(temp, mc.cores = num_cores, verbose = TRUE)
22: draw_posterior(temp, mc.cores = num_cores, verbose = TRUE)
An irrecoverable exception occurred. R is aborting now ...
Warning message:
In mccollect(jobs) : 2 parallel jobs did not deliver results
[?25h[?25h[1] "Elapsed time: 5.32362983398967"
[?25hError in x[[jj]][iseq] <- vjj : replacement has length zero
Calls: summary -> summary.bvarlist -> [<- -> [<-.data.frame
Execution halted
[?25h
 *** caught segfault ***
address 0x7f7433a368c0, cause 'memory not mapped'

Traceback:
 1: .bvectvpalg(object)
 2: bvecpost(object)
 3: doTryCatch(return(expr), name, parentenv, handler)
 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 5: tryCatchList(expr, classes, parentenv, handlers)
 6: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
 7: try(bvecpost(object))
 8: FUN(X[[i]], ...)
 9: eval(expr, env)
10: doTryCatch(return(expr), name, parentenv, handler)
11: tryCatchOne(expr, names, parentenv, handlers[[1L]])
12: tryCatchList(expr, classes, parentenv, handlers)
13: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
14: try(eval(expr, env), silent = TRUE)
15: serialize(what, NULL, xdr = FALSE)
16: sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
17: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
18: FUN(X[[i]], ...)
19: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
20: parallel::mclapply(object, .posterior_bvecmodel, use = FUN, mc.cores = mc.cores,     mc.preschedule = FALSE)
21: draw_posterior.bvecmodel(temp, mc.cores = num_cores, verbose = TRUE)
22: draw_posterior(temp, mc.cores = num_cores, verbose = TRUE)
An irrecoverable exception occurred. R is aborting now ...
Warning message:
In mccollect(jobs) : 2 parallel jobs did not deliver results
[?25h[?25h[1] "Elapsed time: 5.32156208177408"
[?25hError in x[[jj]][iseq] <- vjj : replacement has length zero
Calls: summary -> summary.bvarlist -> [<- -> [<-.data.frame
Execution halted
[?25h